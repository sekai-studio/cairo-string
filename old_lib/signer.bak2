import { ec } from 'elliptic';
import { StarknetContract } from 'hardhat/types';
import { defaultProvider, Provider, Signer as StarkSigner } from 'starknet';
import { getKeyPair, getStarkKey, sign } from 'starknet/dist/utils/ellipticCurve';
import { hashMessage } from 'starknet/dist/utils/hash';
import { stringify } from 'starknet/dist/utils/json';
import { BigNumberish } from 'starknet/dist/utils/number';
import { getSelectorFromName } from 'starknet/dist/utils/stark';

export type BigIntish = string | number | bigint;
type AllowedNetworks = 'localhost' | 'georli-alpha' | 'mainnet-alpha';

export default class Signer {
  private _signer: StarkSigner;
  private _starkKey: ec.KeyPair;
  private _account: StarknetContract;
  public set account(account: StarknetContract) {
    this._account = account;
  }
  public get account() {
    return this._account;
  }

  constructor(network: AllowedNetworks, privateKey: BigNumberish) {
    this._starkKey = getKeyPair(privateKey);
    let provider: Provider;
    if (network === 'localhost') {
      provider = defaultProvider;
      provider.baseUrl = 'http://localhost:5000';
      provider.gatewayUrl = 'http://localhost:5000/gateway';
      provider.feederGatewayUrl = 'http://localhost:5000/feeder_gateway';
    } else {
      provider = new Provider({ network });
    }
    this._signer = new StarkSigner(provider, getStarkKey(this._starkKey), this._starkKey);
  }

  getStarkKey(): string {
    return getStarkKey(this._starkKey);
  }

  sign(msgHash: string): ec.Signature {
    return sign(this._starkKey, msgHash);
  }

  async buildTransaction(
    account: StarknetContract,
    to: string,
    selectorName: string,
    calldata: BigNumberish[],
    nonce?: BigNumberish,
  ) {
    if (nonce === undefined) {
      const { result } = await this._signer.callContract({
        contract_address: this._account.address,
        entry_point_selector: getSelectorFromName('get_nonce'),
      });
      nonce = result[0];
    }

    const selector = getSelectorFromName(selectorName);
    console.log(selectorName);
    console.log(selector.toString());
    const calldataStr = calldata.map(e => e.toString());

    const msgHash = hashMessage(account.address, to, selector, calldataStr, nonce.toString());
    const signature = this.sign(msgHash);

    return {
      selector,
      r: signature.r,
      s: signature.s,
      nonce,
    };
  }

  async sendTransaction(
    to: string,
    selectorName: string,
    calldata: BigNumberish[],
    nonce?: BigNumberish,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ) {
    // TODO type Contract
    const {
      selector,
      r,
      s,
      nonce: nnc,
    } = await this.buildTransaction(this._account, to, selectorName, calldata, nonce);

    return this._signer.invokeFunction(
      this._account.address,
      'execute',
      [to, selector, stringify(calldata), nnc.toString()],
      [r, s],
    );
  }
}

export function toBigInt(data: BigNumberish | BigIntish): bigint {
  if (typeof data === 'bigint') return data;
  return BigInt(data.toString());
}
