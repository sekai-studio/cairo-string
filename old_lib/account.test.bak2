import { expect } from 'chai';
import { starknet } from 'hardhat';

import config from '../test/config';
import Signer from './signer.bak2';

const signer = new Signer('localhost', config.PRIVATE_KEY_1);
// const STARK_KEY_2 = loadPrivateKey(config.PRIVATE_KEY_2);
// const STARK_KEY_PUB_2 = exportPublicKey(STARK_KEY_2);

describe('Account.cairo', function () {
  console.log('Starknet Network used:', config.NETWORK);
  if (config.NETWORK === 'devnet') {
    this.timeout('30s'); // Timeout if >30sec on Local Devnet
  } else {
    this.timeout('5m'); // Timeout if >5min on Alpha Testnet
  }

  /**
   * Deploy all contracts
   */

  this.beforeAll(async function () {
    const accountFactory = await starknet.getContractFactory('Account');
    this.account = await accountFactory.deploy({ _public_key: BigInt(signer.getStarkKey()) });
    signer.account = this.account;

    this.initializableFactory = await starknet.getContractFactory('Initializable');
  });

  /**
   * Run tests
   */

  it('should deploy the Account contract with public key', async function () {
    const { res } = await this.account.call('get_public_key');
    expect(res).to.be.equal(BigInt(signer.getStarkKey()));
  });

  it('should initialize the Initializable contract', async function () {
    const initializable = await this.initializableFactory.deploy();

    const { res: not_initialized } = await initializable.call('initialized');
    expect(not_initialized).to.be.equal(0n);

    await signer.sendTransaction(initializable.address, 'initialize', []);

    const { res: initialized } = await initializable.call('initialized');
    expect(initialized).to.be.equal(1n);
  });

  it('should read through Account', async function () {
    const initializable = await this.initializableFactory.deploy();

    await signer.sendTransaction(initializable.address, 'initialize', []);

    const res = await signer.sendTransaction(initializable.address, 'initialized', []);
    console.log(res);

    const { res: callInitialized } = await initializable.call('initialized');
    // expect(invokeInitialized).to.be.equal(callInitialized);
  });
});
